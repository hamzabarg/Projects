// PIC18F4550 Configuration Bit Settings

// 'C' source line config statements

// CONFIG1L
#pragma config PLLDIV = 2       // PLL Prescaler Selection bits (Divide by 2 (8 MHz oscillator input))
#pragma config CPUDIV = OSC1_PLL2// System Clock Postscaler Selection bits ([Primary Oscillator Src: /1][96 MHz PLL Src: /2])
#pragma config USBDIV = 1       // USB Clock Selection bit (used in Full-Speed USB mode only; UCFG:FSEN = 1) (USB clock source comes directly from the primary oscillator block with no postscale)

// CONFIG1H
#pragma config FOSC = INTOSCIO_EC// Oscillator Selection bits (Internal oscillator, port function on RA6, EC used by USB (INTIO))
#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor disabled)
#pragma config IESO = OFF       // Internal/External Oscillator Switchover bit (Oscillator Switchover mode disabled)

// CONFIG2L
#pragma config PWRT = OFF       // Power-up Timer Enable bit (PWRT disabled)
#pragma config BOR = OFF        // Brown-out Reset Enable bits (Brown-out Reset disabled in hardware and software)
#pragma config BORV = 3         // Brown-out Reset Voltage bits (Minimum setting 2.05V)
#pragma config VREGEN = OFF     // USB Voltage Regulator Enable bit (USB voltage regulator disabled)

// CONFIG2H
#pragma config WDT = OFF        // Watchdog Timer Enable bit (WDT disabled (control is placed on the SWDTEN bit))
#pragma config WDTPS = 32768    // Watchdog Timer Postscale Select bits (1:32768)

// CONFIG3H
#pragma config CCP2MX = ON      // CCP2 MUX bit (CCP2 input/output is multiplexed with RC1)
#pragma config PBADEN = OFF     // PORTB A/D Enable bit (PORTB<4:0> pins are configured as digital I/O on Reset)
#pragma config LPT1OSC = OFF    // Low-Power Timer 1 Oscillator Enable bit (Timer1 configured for higher power operation)
#pragma config MCLRE = ON       // MCLR Pin Enable bit (MCLR pin enabled; RE3 input pin disabled)

// CONFIG4L
#pragma config STVREN = OFF     // Stack Full/Underflow Reset Enable bit (Stack full/underflow will not cause Reset)
#pragma config LVP = OFF        // Single-Supply ICSP Enable bit (Single-Supply ICSP disabled)
#pragma config ICPRT = OFF      // Dedicated In-Circuit Debug/Programming Port (ICPORT) Enable bit (ICPORT disabled)
#pragma config XINST = OFF      // Extended Instruction Set Enable bit (Instruction set extension and Indexed Addressing mode disabled (Legacy mode))

// CONFIG5L
#pragma config CP0 = OFF        // Code Protection bit (Block 0 (000800-001FFFh) is not code-protected)
#pragma config CP1 = OFF        // Code Protection bit (Block 1 (002000-003FFFh) is not code-protected)
#pragma config CP2 = OFF        // Code Protection bit (Block 2 (004000-005FFFh) is not code-protected)
#pragma config CP3 = OFF        // Code Protection bit (Block 3 (006000-007FFFh) is not code-protected)

// CONFIG5H
#pragma config CPB = OFF        // Boot Block Code Protection bit (Boot block (000000-0007FFh) is not code-protected)
#pragma config CPD = OFF        // Data EEPROM Code Protection bit (Data EEPROM is not code-protected)

// CONFIG6L
#pragma config WRT0 = OFF       // Write Protection bit (Block 0 (000800-001FFFh) is not write-protected)
#pragma config WRT1 = OFF       // Write Protection bit (Block 1 (002000-003FFFh) is not write-protected)
#pragma config WRT2 = OFF       // Write Protection bit (Block 2 (004000-005FFFh) is not write-protected)
#pragma config WRT3 = OFF       // Write Protection bit (Block 3 (006000-007FFFh) is not write-protected)

// CONFIG6H
#pragma config WRTC = OFF       // Configuration Register Write Protection bit (Configuration registers (300000-3000FFh) are not write-protected)
#pragma config WRTB = OFF       // Boot Block Write Protection bit (Boot block (000000-0007FFh) is not write-protected)
#pragma config WRTD = OFF       // Data EEPROM Write Protection bit (Data EEPROM is not write-protected)

// CONFIG7L
#pragma config EBTR0 = OFF      // Table Read Protection bit (Block 0 (000800-001FFFh) is not protected from table reads executed in other blocks)
#pragma config EBTR1 = OFF      // Table Read Protection bit (Block 1 (002000-003FFFh) is not protected from table reads executed in other blocks)
#pragma config EBTR2 = OFF      // Table Read Protection bit (Block 2 (004000-005FFFh) is not protected from table reads executed in other blocks)
#pragma config EBTR3 = OFF      // Table Read Protection bit (Block 3 (006000-007FFFh) is not protected from table reads executed in other blocks)

// CONFIG7H
#pragma config EBTRB = OFF      // Boot Block Table Read Protection bit (Boot block (000000-0007FFh) is not protected from table reads executed in other blocks)

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

#include <xc.h>
#include <stdlib.h>
#define _XTAL_FREQ 8000000  // Internal oscillator frequency (8 MHz)
#define ldata PORTD
#define rs LATE2
#define en LATE0

void UART_Init(long baudrate);
void UART_Write(char data);
void UART_Write_Text(const char *text);

void LCD_Init();
void lcdcmd(unsigned char cmd);
void lcddata(unsigned char data);
unsigned char units;
unsigned char tens;
unsigned char hund;
unsigned char setpointunits;
unsigned char setpointtens;
unsigned char setpointhund;

unsigned char setpoints[] = { 19,23,27,31,35,39,43,47,51,55,59,63,67,71,
                      75,79,80,82,83,84,85,86,87,89,
                      90,91,93,96,99,103,106,110,106,103,100,96,
                      92,90,87,85,82,80,77,75,72,67,65,62,60,
                      57,55,52,50,47,45,42,40,38,35,32,30,27,25,22,20,
                      17};
char v = 0;
float Kp = 5.0,Ki = 0.05,Kd = 1.0;
int error;
char previous_error = 0;
int integral;
int derivative; 
float output;
int pwm;

void __interrupt()ISR(void)
{
    if(T0IF == 1)
    {
        LATC0 = ~LATC0;
        v++;
        TMR0H = 0x67;
        TMR0L = 0x6A;
        T0IF = 0;
    }
}

void main(void) 
{
    TRISC0 = 0;
    OSCCON = 0B01100010;
    LCD_Init();
    UART_Init(9600);
    
    TRISC2 = 0;
    TRISC1 = 0;
    
    T2CON = 0B00000000;
    PR2 = 255;
    TMR2ON = 1;
    
    CCP1CON = 0B00001100;
    CCPR1L = 0;
    CCP2CON = 0B00001100;
    CCPR2L = 0;
    
    T0CON = 0B00010111;
    TMR0H = 0x67;
    TMR0L = 0x6A;
    GIE=1;
    T0IE=1;
    
    LATB2 = 1;

    SSPSTAT = 0x40; //
    SSPCON1 = 0x20; // master mode enable , fosc/4

    TMR0ON = 1;
    while (1)
    {
        unsigned char high_byte, low_byte;
        unsigned int temp;

        LATB2 = 0;
        __delay_ms(40);

        SSPBUF = 0x00;
        while(!SSPSTATbits.BF);
        high_byte = SSPBUF;

        SSPBUF = 0x00;
        while(!SSPSTATbits.BF);
        low_byte = SSPBUF;

        LATBbits.LATB2 = 1;

        temp = ((unsigned int)high_byte << 8) | low_byte;
        temp = temp >> 4;

        temp = temp - 37          ;
           
        error = (int)(setpoints[v] - temp);
        integral += (int)(error);
        derivative = (int)(error - previous_error);
        output = (Kp * error); // + (Ki * integral) + (Kd * derivative);
        pwm = (int)(output * 2.55);
        previous_error = error;
        
        if(pwm >255)
        {
            CCPR1L = 255;
            CCPR2L = 0;
        }
        
        else if(pwm <= 255 && pwm >= 0)
        {
            CCPR1L = pwm;
            CCPR2L = 0;
        }
        
        else if(pwm < 0)
        {
            CCPR1L = 0;
            CCPR2L = abs(pwm);
        }
        
        hund = temp / 100;
        tens = ((temp / 10) % 10);
        units = temp % 10;
        
        setpointhund = setpoints[v] / 100;
        setpointtens = ((setpoints[v] / 10) % 10);
        setpointunits = setpoints[v] % 10;
        
        UART_Write_Text("Current:");
        UART_Write(hund + 48);
        UART_Write(tens + 48);
        UART_Write(units + 48);
        UART_Write(0xDF);
        UART_Write('C');
        UART_Write_Text("\t");
        UART_Write_Text("Setpoint:");
        UART_Write(setpointhund + 48);
        UART_Write(setpointtens + 48);
        UART_Write(setpointunits + 48);
        UART_Write(0xDF);
        UART_Write('C');
        UART_Write_Text("\r\n");
        __delay_ms(1000);
        
        lcdcmd(0x01);
        __delay_ms(5);
        lcddata(hund + '0');
        __delay_ms(2);
        lcddata(tens + '0');
        __delay_ms(2);
        lcddata(units + '0');
        __delay_ms(2);
        lcddata(0xDF);
        __delay_ms(2);
        lcddata('C');
        __delay_ms(2);
    }
}

void LCD_Init()
{
    ADCON1 = 0B00001111;
    TRISD = 0;
    TRISE = 0;

    en = 0;
    __delay_ms(200);
    
    lcdcmd(0x38);
    __delay_ms(5);
    
    lcdcmd(0x0E);
    __delay_ms(5);
    
    lcdcmd(0x01);
    __delay_ms(5);
    
    lcdcmd(0x06);
    __delay_ms(5);
    
    lcdcmd(0x80);
    __delay_ms(5);

    TRISB0 = 1;  // RB0 = SDI (input)
    TRISB1 = 0;  // RB1 = SCK (output)
    TRISB2 = 0;  // RB2 = CS (output)
}

void lcdcmd(unsigned char cmd)
{
    ldata = cmd;
    rs = 0;
    en = 1;
    __delay_ms(2);
    en = 0;
}

void lcddata(unsigned char data)
{
    ldata = data;
    rs = 1;
    en = 1;
    __delay_ms(2);
    en = 0;
}

void UART_Init(long baudrate) {
    // Set internal oscillator frequency (8 MHz)
    OSCCON = 0b01110000; // IRCF = 111 (8 MHz), SCS = 00 (Primary clock source)

    TRISC6 = 0;   // TX pin as output
    TRISC7 = 1;   // RX pin as input

    // Baud Rate Setting (Low Speed, BRGH = 0)
    BRGH = 0;
    SPBRG = (_XTAL_FREQ / (64UL * baudrate)) - 1;

    SYNC = 0;     // Asynchronous mode
    SPEN = 1;     // Enable serial port
    TXEN = 1;     // Enable transmitter
    CREN = 1;     // Enable receiver
}
void UART_Write(char data) {
    while (!TXIF);   // Wait until TX buffer is empty
    TXREG = data;
}
void UART_Write_Text(const char *text) {
    while (*text) {
        UART_Write(*text++);
    }
}